<!DOCTYPE html>
<html translate="no">
<script type="x-shader/x-vertex" id="vertexshader">

    varying vec2 vUv;

    void main() {

        vUv = uv;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

</script>

<script type="x-shader/x-fragment" id="fragmentshader">

    uniform sampler2D baseTexture;
    uniform sampler2D bloomTexture;

    varying vec2 vUv;

    void main() {

        gl_FragColor = vec4( 1,1,1,1 ) *  texture2D( baseTexture, vUv ) + vec4( 1,1,1,0 ) * texture2D( bloomTexture, vUv ) ;

    }

</script>
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
        }
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/libs/ammo.wasm.js"></script>
<script defer type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { AmmoPhysics } from 'three/addons/physics/AmmoPhysics.js';
    import { ConvexObjectBreaker } from 'three/addons/misc/ConvexObjectBreaker.js';
    import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    //import Stats from 'three/addons/libs/stats.module.js';
    let
        dispMovVal,
        sensor,
        container,
        estado,
        camera,
        controles,
        cena,
        geradorImagem,
        iniSessao = {},
        carregadorTextura,
        carregadorGLTF,
        tempIni,
        tempFin,
        carregando = false,
        medGlob,
        imgBola,
        posCesta = new THREE.Vector3(0, 0, 0),
        cestaEmCena = [],
        cestaFisicaEmCena = [],
        luzDestaqueEmCena = [],
        configColisao,
        despachante,
        broadphase,
        solucionador,
        mundoFisico,
        transformAux1,
        tempBtVec3_1,
        xRotG = 0,
        yRotG = 0,
        zRotG = 0,
        numObjectsToRemove = 0,
        compositorBrilho,
        compositorFinal,
        passeBrilho,
        gravY = 1,
        gravZ = 0,
        gravX = 0,
        carregadorFonte,
        capsulaCamera = new THREE.Mesh(),
        refMesh = new THREE.Mesh(),
        passeAntiCerrilhamento;
    let frustum = new THREE.Frustum();
    const canvas = document.getElementById('threeRenderer'),
        clock = new THREE.Clock(),
        coordLancamento = new THREE.Vector2(0, 0),
        lancadorRaios = new THREE.Raycaster(),
        bolaMaterial = new THREE.MeshPhongMaterial(),
        gravidade = 9.8,
        margem = 0,
        quabravelConvexo = new ConvexObjectBreaker(),
        corposRigidos = [],
        pos = new THREE.Vector3(),
        quat = new THREE.Quaternion(),
        objetosARemover = [],
        pontoImpacto = new THREE.Vector3(),
        normalImpacto = new THREE.Vector3(),
        contaPontos = [],
        camadaBrilho = new THREE.Layers(),
        histRot = {
            xyz: {
                lista: Object.seal(new Array(4).fill({ x: 0, y: 0, z: 0 })),
                atual: 0
            },
            quaternion: {
                lista: Object.seal(new Array(32).fill(quat)),
                atual: 0
            }
        };
    camadaBrilho.set(1);
    for (let i = 0; i < 500; i++) {
        objetosARemover[i] = null;
    }
    AmmoPhysics().then(function (AmmoLib) {
        inic();
    });
    const fisicaSensor = window.setInterval(() => {
        if (carregando) {
            let escala = (new Date() - tempIni) / 40;
            medGlob.scale.z = escala;
            medGlob.scale.y = escala;
            medGlob.scale.x = escala;
            medGlob.material.opacity += 0.025;
            medGlob.material.emissiveIntensity += 0.0025;
            passeBrilho.strength = escala / 3.375;
            medGlob.material.emissive.setRGB(escala * 2, escala, escala);
        }
    }, 16.6);
    function dispMov() {
        if (dispMovVal !== undefined) {
            return dispMovVal;
        } else {
            let nav = navigator;
            const a = nav.userAgent || nav.vendor ||
                (typeof window !== 'undefined' ? window.opera : '');
            if (!a) {
                const navAny = nav;
                return navAny.userAgentData && navAny.userAgentData.mobile;
            }
            dispMovVal = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
                .test(a) ||
                /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
                    .test(a.substr(0, 4));
            return dispMovVal;
        }
    }
    function dispIOS() {
        const regex = /iPhone|iPad|iPod/i;
        return regex.test(navigator.userAgent);
    }
    async function inic() {
        await inicGraficos();
        await inicFisica();
        await criarObjetos();
        await inicEntradas();
        await carregarCesta();
        animar();
    }
    async function carregarCesta() {
        let _x = (Math.random() + 0.8) * 2.5 * Math.sign(Math.random() - 0.5);
        let _z = (Math.random() + 0.8) * 2.5 * Math.sign(Math.random() - 0.5);
        let _y = (Math.random() + 1.25) * 2;
        const _meshes = [];
        await carregadorGLTF.load('/models/cesta2.glb', async gltf => {
            await gltf.scene.children.map(_ch => {
                if (_ch.isMesh) {
                    _meshes.push(_ch);
                }
            });
            for (let _i = 0; _i < _meshes.length; _i++) {
                await cena.add(_meshes[_i]);
                await cestaEmCena.push(_meshes[_i]);
                _meshes[_i].castShadow = true;
                _meshes[_i].receiveShadow = true;
                if (_meshes[_i].name === 'cesta') {
                    await _meshes[_i].position.set(_x, _y, _z);
                    await _meshes[_i].lookAt(0, _y, 0);
                    await gerarFisicaGLB(_meshes[_i]);
                } else {
                    let _ori = await new THREE.Vector3(0, 0, 0);
                    let _pos = await new THREE.Vector3(_x, _y, _z);
                    await _meshes[_i].position.set(_x + ((_x / (_pos.distanceTo(_ori))) * 0.7), _y, _z + ((_z / (_pos.distanceTo(_ori))) * 0.7));
                    await _meshes[_i].lookAt(0, _y, 0);
                    refMesh.lookAt(_meshes[_i].position.x, _meshes[_i].position.y, _meshes[_i].position.z);
                    _meshes[_i].rotation.y * 0.9;
                    await gerarFisicaGLB(_meshes[_i]);
                }
                await posCesta.set(_meshes[_i].position.x, _meshes[_i].position.y, _meshes[_i].position.z);

            }
        });
        let _luz = new THREE.PointLight(0xffffff, 8, 2, 0.5);
        _luz.position.set(_x, _y, _z);
        cena.add(_luz);
        luzDestaqueEmCena.push(_luz);
    }
    function ajudaDirecao(evento) {
        frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
        if (!frustum.containsPoint(posCesta)) {
            if (Math.sign(camera.getWorldDirection(camera.position).x) > 0) {
                if (Math.sign(camera.getWorldDirection(camera.position).z) > 0) {
                    if (Math.sign(posCesta.x) > 0) {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: +, z: + }', 'Cesta: { x: +, z: + }');
                            if (posCesta.x < camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'block';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'block';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        } else {
                            //console.log('Camera: { x: +, z: + }', 'Cesta: { x: +, z: - }');
                            if (posCesta.z > camera.getWorldDirection(camera.position).z * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        }
                    } else {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: +, z: + }', 'Cesta: { x: -, z: + }');
                            if (posCesta.x < camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        } else {
                            //console.log('Camera: { x: +, z: + }', 'Cesta: { x: -, z: - }', 'Atrás');
                            window.parent.esqPerto.style.display = 'none';
                            window.parent.esqLonge.style.display = 'none';
                            window.parent.dirPerto.style.display = 'none';
                            window.parent.dirLonge.style.display = 'none';
                            window.parent.atras.style.display = 'block';
                        }
                    }
                } else {
                    if (Math.sign(posCesta.x) > 0) {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: +, z: - }', 'Cesta: { x: +, z: + }');
                            if (posCesta.z > camera.getWorldDirection(camera.position).z * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        } else {
                            //console.log('Camera: { x: +, z: - }', 'Cesta: { x: +, z: - }');
                            if (posCesta.x > camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'block';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'block';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        }
                    } else {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: +, z: - }', 'Cesta: { x: -, z: + }', 'Atrás');
                            window.parent.esqPerto.style.display = 'none';
                            window.parent.esqLonge.style.display = 'none';
                            window.parent.dirPerto.style.display = 'none';
                            window.parent.dirLonge.style.display = 'none';
                            window.parent.atras.style.display = 'block';
                        } else {
                            //console.log('Camera: { x: +, z: - }', 'Cesta: { x: -, z: - }');
                            if (posCesta.x > camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        }
                    }
                }
            } else {
                if (Math.sign(camera.getWorldDirection(camera.position).z) > 0) {
                    if (Math.sign(posCesta.x) > 0) {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: -, z: + }', 'Cesta: { x: +, z: + }');
                            if (posCesta.x < camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        } else {
                            //console.log('Camera: { x: -, z: + }', 'Cesta: { x: +, z: - }', 'Atrás');
                            window.parent.esqPerto.style.display = 'none';
                            window.parent.esqLonge.style.display = 'none';
                            window.parent.dirPerto.style.display = 'none';
                            window.parent.dirLonge.style.display = 'none';
                            window.parent.atras.style.display = 'block';
                        }
                    } else {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: -, z: + }', 'Cesta: { x: -, z: + }');
                            if (posCesta.x < camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'block';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'block';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        } else {
                            //console.log('Camera: { x: -, z: + }', 'Cesta: { x: -, z: - }');
                            if (posCesta.z < camera.getWorldDirection(camera.position).z * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        }
                    }
                } else {
                    if (Math.sign(posCesta.x) > 0) {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: -, z: - }', 'Cesta: { x: +, z: + }', 'Atrás');
                            window.parent.esqPerto.style.display = 'none';
                            window.parent.esqLonge.style.display = 'none';
                            window.parent.dirPerto.style.display = 'none';
                            window.parent.dirLonge.style.display = 'none';
                            window.parent.atras.style.display = 'block';
                        } else {
                            //console.log('Camera: { x: -, z: - }', 'Cesta: { x: +, z: - }');
                            if (posCesta.x > camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        }
                    } else {
                        if (Math.sign(posCesta.z) > 0) {
                            //console.log('Camera: { x: -, z: - }', 'Cesta: { x: -, z: + }');
                            if (posCesta.z < camera.getWorldDirection(camera.position).z * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'block';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'block';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        } else {
                            //console.log('Camera: { x: -, z: - }', 'Cesta: { x: -, z: - }');
                            if (posCesta.x > camera.getWorldDirection(camera.position).x * camera.position.distanceTo(posCesta)) {
                                window.parent.esqPerto.style.display = 'none';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'block';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            } else {
                                window.parent.esqPerto.style.display = 'block';
                                window.parent.esqLonge.style.display = 'none';
                                window.parent.dirPerto.style.display = 'none';
                                window.parent.dirLonge.style.display = 'none';
                                window.parent.atras.style.display = 'none';
                            }
                        }
                    }
                }
            }
        } else {
            window.parent.esqPerto.style.display = 'none';
            window.parent.esqLonge.style.display = 'none';
            window.parent.dirPerto.style.display = 'none';
            window.parent.dirLonge.style.display = 'none';
            window.parent.atras.style.display = 'none';
        }
    }
    async function inicGraficos() {
        container = await document.getElementById('threeRenderer');
        camera = await new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.1, 100);
        await camera.position.set(0, 1.8, 0);
        capsulaCamera.add(camera);
        dispMov() && !dispIOS() && (capsulaCamera.rotation.x = -Math.PI / 2);
        cena = await new THREE.Scene();
        cena.add(capsulaCamera);
        await refMesh.position.set(0, camera.position.y + capsulaCamera.position.y, 0);
        cena.add(refMesh);
        geradorImagem = await new THREE.WebGLRenderer({ antialias: true, alpha: dispMov() });
        geradorImagem.toneMapping = THREE.ReinhardToneMapping;
        await geradorImagem.setPixelRatio(window.devicePixelRatio);
        await geradorImagem.setSize(window.innerWidth, window.innerHeight);
        //await geradorImagem.setViewport(-window.innerWidth / 2, -window.innerHeight / 2, window.innerWidth * 2, window.innerHeight * 2);
        geradorImagem.shadowMap.enabled = true;
        await container.appendChild(geradorImagem.domElement);

        const geraCena = await new RenderPass(cena, camera);
        passeBrilho = await new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1, 1, 1);
        passeBrilho.threshold = 0;
        passeBrilho.strength = 0.05;
        passeBrilho.radius = 0;
        compositorBrilho = await new EffectComposer(geradorImagem);
        compositorBrilho.renderToScreen = false;
        compositorBrilho.renderer.preserveDrawingBuffer = true;
        await compositorBrilho.addPass(geraCena);
        await compositorBrilho.addPass(passeBrilho);
        await compositorBrilho.renderer.setPixelRatio(window.devicePixelRatio);
        await compositorBrilho.renderer.setSize(window.innerWidth, window.innerHeight);
        const passeMistura = await new ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: compositorBrilho.renderTarget2.texture }
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                defines: {},
            }), 'baseTexture'
        );
        const passeSaida = await new OutputPass();
        passeAntiCerrilhamento = await new ShaderPass(FXAAShader);
        passeAntiCerrilhamento.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * window.devicePixelRatio);
        passeAntiCerrilhamento.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * window.devicePixelRatio);
        compositorFinal = await new EffectComposer(geradorImagem);
        await compositorFinal.addPass(geraCena);
        await compositorFinal.addPass(passeMistura);
        await compositorFinal.addPass(passeSaida);
        await compositorFinal.addPass(passeAntiCerrilhamento);
        await compositorFinal.renderer.setPixelRatio(window.devicePixelRatio);
        await compositorFinal.renderer.setSize(window.innerWidth, window.innerHeight);
        if (dispMov()) {
            capsulaCamera.position.y = 1.8;
            // !dispIOS()
            if (!dispIOS()) {
                sensor = await new AbsoluteOrientationSensor({ frequency: 60 });
                await sensor.start();
                window.parent.txtRef.current.style.display = 'none';
                let _rotQuaternion = new THREE.Quaternion(), _medQuat = new Array(4);
                sensor.onreading = async (leitura) => {
                    _medQuat[0] = leitura.currentTarget.quaternion[0];
                    _medQuat[1] = leitura.currentTarget.quaternion[1];
                    _medQuat[2] = leitura.currentTarget.quaternion[2];
                    _medQuat[3] = leitura.currentTarget.quaternion[3];
                    await _rotQuaternion.fromArray([leitura.currentTarget.quaternion[0], leitura.currentTarget.quaternion[1], leitura.currentTarget.quaternion[2], leitura.currentTarget.quaternion[3]]);
                    await histRot.quaternion.lista.map((_quat, _i) => {
                        _medQuat[0] = (_medQuat[0] + _quat._x) / 2;
                        _medQuat[1] = (_medQuat[1] + _quat._y) / 2;
                        _medQuat[2] = (_medQuat[2] + _quat._z) / 2;
                        _medQuat[3] = (_medQuat[3] + _quat._w) / 2;
                    });
                    await histRot.quaternion.lista.splice(histRot.quaternion.atual, 1, _rotQuaternion);
                    if (histRot.quaternion.atual < 31) {
                        histRot.quaternion.atual++;
                    } else {
                        histRot.quaternion.atual = 0;
                    }
                    await _rotQuaternion.fromArray(_medQuat);
                    camera.rotation.setFromQuaternion(_rotQuaternion);
                    if (carregando) {
                        let dir = camera.getWorldDirection(new THREE.Vector3(0, 1.8, 0));
                        medGlob.position.set(dir.x * 10, dir.y * 10, dir.z * 10);
                    }
                    ajudaDirecao();
                };
            } else {
                window.parent.txtRef.current.innerHTML = (navigator.language !== 'pt-BR' && navigator.language !== 'pt') ? 'Touch here to begin!' : 'Toque aqui para iniciar!';
                window.parent.txtRef.current.addEventListener('click', () => {
                    window.DeviceOrientationEvent.requestPermission().then(resposta => {
                        if (resposta === 'granted') {
                            window.parent.txtRef.current.style.display = 'none';
                            window.parent.txtRef.current.removeEventListener('click', () => { });
                            window.parent.addEventListener('devicemotion', evento => {
                                gravX = evento.accelerationIncludingGravity.x / 9.8;
                                gravY = Math.abs(evento.accelerationIncludingGravity.y / 9.8);
                                gravZ = evento.accelerationIncludingGravity.z / 9.8;
                            });
                            window.parent.addEventListener("deviceorientation", async evento => {
                                let _novaRot = {
                                    x: (camera.rotation.x * 3 + ((((Math.abs(evento.beta - 90) / 180) * Math.PI) - Math.abs(gravX)) * Math.sign(gravZ))) / 4,
                                    y: (capsulaCamera.rotation.y * 3 + (gravX + Math.PI - ((evento.webkitCompassHeading / 360) * 2 * Math.PI))) / 4,
                                    z: (capsulaCamera.rotation.z * 3 + (-(Math.abs(evento.gamma) / 90) * Math.PI * Math.sign(gravX) * (1 - gravY))) / 4
                                };
                                histRot.xyz.lista.splice(histRot.xyz.atual, 1, { x: _novaRot.x, y: _novaRot.y, z: _novaRot.z });
                                await histRot.xyz.lista.map(_rot => {
                                    _novaRot.x = (_rot.x + _novaRot.x) / 2;
                                    _novaRot.y = (_rot.y + _novaRot.y) / 2;
                                    _novaRot.z = (_rot.z + _novaRot.z) / 2;
                                });
                                if (histRot.xyz.atual < 3) {
                                    histRot.xyz.atual++;
                                } else {
                                    histRot.xyz.atual = 0;
                                }
                                camera.rotation.x = _novaRot.x;
                                capsulaCamera.rotation.y = _novaRot.y;
                                capsulaCamera.rotation.z = _novaRot.z;
                                if (carregando) {
                                    let dir = camera.getWorldDirection(new THREE.Vector3(0, 1.8, 0));
                                    medGlob.position.set(dir.x * 10, dir.y * 10, dir.z * 10);
                                }
                                ajudaDirecao();
                            }, true);
                        } else {
                            if (navigator.language !== 'pt-BR' && navigator.language !== 'pt') {
                                window.parent.txtRef.current.innerHTML = 'Permition denied. Touch here to try again.';
                            }
                            else {
                                window.parent.txtRef.current.innerHTML = 'Permissão negada. Toque aqui para tentar novamente.';
                            }
                        }
                    }).catch(erro => alert('erro' + erro));
                });
            }
        } else {
            window.parent.txtRef.current.style.pointerEvents = 'none';
            window.parent.txtRef.current.parentElement.style = 'pointer-events: none !important;';
            if (navigator.language !== 'pt-BR' && navigator.language !== 'pt') {
                window.parent.txtRef.current.innerHTML = 'Click on the scene to activate controls.';
            } else {
                window.parent.txtRef.current.innerHTML = 'Clique na cena para ativar os controles.';
            }
            controles = await new PointerLockControls(camera, geradorImagem.domElement);
            controles.pointerSpeed = 0.75;
            controles.maxPolarAngle = Math.PI;
            geradorImagem.domElement.addEventListener('click' || 'touch', (evento) => {
                if (!controles.isLocked) {
                    if (evento.button === 0) {
                        geradorImagem.domElement.requestPointerLock({ unadjustedMovement: true });
                        capsulaCamera.position.y = 1.8;
                        //controles.lock();
                        window.parent.txtRef.current.style.display = 'none';
                        window.addEventListener('pointermove', () => ajudaDirecao());
                    }
                }
            });
        }
        carregadorTextura = new THREE.TextureLoader();
        carregadorGLTF = new GLTFLoader();
        carregadorFonte = new FontLoader();
        const luzAmbiente = new THREE.AmbientLight(0xffffff, 1);
        cena.add(luzAmbiente);
        const luz = new THREE.DirectionalLight(0xffffff, 1.5);
        luz.position.set(- 12, 25, 12);
        luz.castShadow = true;
        const d = 64;
        luz.shadow.camera.left = -d;
        luz.shadow.camera.right = d;
        luz.shadow.camera.top = d;
        luz.shadow.camera.bottom = -d;
        luz.shadow.camera.near = 2;
        luz.shadow.camera.far = 128;
        luz.shadow.mapSize.x = 2048;
        luz.shadow.mapSize.y = 2048;
        cena.add(luz);
        luz.lookAt(new THREE.Vector3(0, 0, 0));
        const luz1 = new THREE.DirectionalLight(0xffffff, 1.5);
        luz1.position.set(12, 25, -12);
        luz1.castShadow = true;
        luz1.shadow.camera.left = -d;
        luz1.shadow.camera.right = d;
        luz1.shadow.camera.top = d;
        luz1.shadow.camera.bottom = -d;
        luz1.shadow.camera.near = 2;
        luz1.shadow.camera.far = 128;
        luz1.shadow.mapSize.x = 2048;
        luz1.shadow.mapSize.y = 2048;
        cena.add(luz1);
        luz1.lookAt(new THREE.Vector3(0, 0, 0));
        //estado = new Stats();
        //container.appendChild(estado.domElement);
        window.addEventListener('resize', aoRedimensionarJanela);
    }
    function inicFisica() {
        configColisao = new Ammo.btDefaultCollisionConfiguration();
        despachante = new Ammo.btCollisionDispatcher(configColisao);
        broadphase = new Ammo.btDbvtBroadphase();
        solucionador = new Ammo.btSequentialImpulseConstraintSolver();
        mundoFisico = new Ammo.btDiscreteDynamicsWorld(despachante, broadphase, solucionador, configColisao);
        mundoFisico.setGravity(new Ammo.btVector3(0, - gravidade, 0));
        transformAux1 = new Ammo.btTransform();
        tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);
    }
    function criarObjeto(mass, halfExtents, pos, quat, material) {
        const objeto = new THREE.Mesh(new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2), material);
        objeto.position.copy(pos);
        objeto.quaternion.copy(quat);
        quabravelConvexo.prepareBreakableObject(objeto, mass, new THREE.Vector3(), new THREE.Vector3(), true);
        criarDestrocosDeObjetoQuebravel(objeto);
    }
    function criarObjetos() {
        dispMov()
            ? pos.set(0, -10, 0)
            : pos.set(0, 0, 0);
        quat.set(0, 0, 0, 1);
        const piso = criarParalelepipedoComFisica(28, 1, 28, 0, pos, quat, new THREE.MeshPhongMaterial({}));
        piso.receiveShadow = true;
        carregadorTextura.load('../materials/bamboo/bamboo-semigloss-albedo.png', async function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(28, 28);
            if (dispMov()) {
                piso.material.alphaTest = 0.5;
                piso.material.opacity = 0;
            } else {
                piso.material.map = texture;
                piso.material.normalMap = await carregadorTextura.load('../materials/bamboo/bamboo-semigloss-normal.png', texture => texture);
                piso.material.aoMap = await carregadorTextura.load('../materials/bamboo/bamboo-semigloss-ao.png', texture => texture);
                piso.material.specularMap = await carregadorTextura.load('../materials/bamboo/bamboo-semigloss-roughness.png', texture => texture);
            }
            piso.material.needsUpdate = true;
        });
        pos.set(-14, 12.5, 0);
        quat.set(0, 0.7071068, 0, .7071068);
        criarParalelepipedoComFisica(28, 25, 1, 0, pos, quat, new THREE.MeshStandardMaterial({ color: criarCorAleatoria(), opacity: dispMovVal ? 0 : 1, alphaTest: dispMovVal ? 0.1 : 1 }));
        pos.set(14, 12.5, 0);
        criarParalelepipedoComFisica(28, 25, 1, 0, pos, quat, new THREE.MeshStandardMaterial({ color: criarCorAleatoria(), opacity: dispMovVal ? 0 : 1, alphaTest: dispMovVal ? 0.1 : 1 }));
        pos.set(0, 12.5, -14);
        quat.set(0, 0, 0, 1);
        criarParalelepipedoComFisica(28, 25, 1, 0, pos, quat, new THREE.MeshStandardMaterial({ color: criarCorAleatoria(), opacity: dispMovVal ? 0 : 1, alphaTest: dispMovVal ? 0.1 : 1 }));
        pos.set(0, 12.5, 14);
        criarParalelepipedoComFisica(28, 25, 1, 0, pos, quat, new THREE.MeshStandardMaterial({ color: criarCorAleatoria(), opacity: dispMovVal ? 0 : 1, alphaTest: dispMovVal ? 0.1 : 1 }));
    }
    function criarParalelepipedoComFisica(sx, sy, sz, mass, pos, quat, material) {
        const objeto = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
        objeto.castShadow = true;
        objeto.receiveShadow = true;
        const shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
        shape.setMargin(margem);
        criarCorpoRigido(objeto, shape, mass, pos, quat);
        return objeto;
    }
    async function gerarFisicaGLB(objeto) {
        const rot = await new THREE.Euler(objeto.rotation._x, objeto.rotation._y, objeto.rotation._z);
        const quat = await new THREE.Quaternion(objeto.quaternion._x, objeto.quaternion._y, objeto.quaternion._z, objeto.quaternion._w);
        let posVertices = await objeto.geometry.getAttribute('position').array,
            qnt = await objeto.geometry.getAttribute('position').count;
        if (objeto.name === 'cesta') {
            const malha = await new Ammo.btTriangleMesh(true, true);
            for (let i = 0; i < qnt; i += 3) {
                malha.addTriangle(new Ammo.btVector3(posVertices[i * 3], posVertices[i * 3 + 1], posVertices[i * 3 + 2]), new Ammo.btVector3(posVertices[(i + 1) * 3], posVertices[(i + 1) * 3 + 1], posVertices[(i + 2) * 3 + 2]), new Ammo.btVector3(posVertices[(i + 2) * 3], posVertices[(i + 2) * 3 + 1], posVertices[(i + 2) * 3 + 2]), true);
            }
            const forma = await new Ammo.btBvhTriangleMeshShape(malha, true, true);
            await forma.setMargin(margem);
            const corpo = await criarCorpoRigido(objeto, forma, 0);
            cestaFisicaEmCena.push(corpo);
        } else {
            await objeto.rotation.set(0, 0, 0);
            await objeto.quaternion.set(0, 0, 0, 1);
            await objeto.geometry.computeBoundingBox();
            await objeto.rotation.set(rot._x, rot._y, rot._z);
            await objeto.quaternion.set(quat._x, quat._y, quat._z, quat._w);
            let larg = objeto.geometry.boundingBox.max.x - objeto.geometry.boundingBox.min.x, alt = objeto.geometry.boundingBox.max.y - objeto.geometry.boundingBox.min.y, prof = objeto.geometry.boundingBox.max.z - objeto.geometry.boundingBox.min.z;
            const forma = await new Ammo.btBoxShape(new Ammo.btVector3(alt / 2, larg / 2, prof / 2));
            forma.setMargin(margem);
            const corpo = await criarCorpoRigido(objeto, forma, 0, objeto.position, objeto.quaternion);
            cestaFisicaEmCena.push(corpo);
        }
    }
    function criarDestrocosDeObjetoQuebravel(objeto) {
        objeto.castShadow = true;
        objeto.receiveShadow = true;
        const shape = createConvexHullPhysicsShape(objeto.geometry.attributes.position.array);
        shape.setMargin(margem);
        const body = criarCorpoRigido(objeto, shape, objeto.userData.mass, null, null, objeto.userData.velocity, objeto.userData.angularVelocity);
        const btVecUserData = new Ammo.btVector3(0, 0, 0);
        btVecUserData.threeObject = objeto;
        body.setUserPointer(btVecUserData);
    }
    function removerDestrocos(objeto) {
        cena.remove(objeto);
        mundoFisico.removeRigidBody(objeto.userData.physicsBody);
    }
    function createConvexHullPhysicsShape(coords) {
        const forma = new Ammo.btConvexHullShape();
        for (let i = 0, il = coords.length; i < il; i += 3) {
            tempBtVec3_1.setValue(coords[i], coords[i + 1], coords[i + 2]);
            const lapedra = (i >= (il - 3));
            forma.addPoint(tempBtVec3_1, lapedra);
        }
        return forma;
    }
    function criarCorpoRigido(objeto, physicsShape, mass, pos, quat, vel, angVel) {
        if (pos) {
            objeto.position.copy(pos);
        } else {
            pos = objeto.position;
        }
        if (quat) {
            objeto.quaternion.copy(quat);
        } else {
            quat = objeto.quaternion;
        }
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        const motionState = new Ammo.btDefaultMotionState(transform);
        const localInertia = new Ammo.btVector3(0, 0, 0);
        physicsShape.calculateLocalInertia(mass, localInertia);
        const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
        const body = new Ammo.btRigidBody(rbInfo);
        body.setFriction(0.5);
        if (vel) {
            body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
        }
        if (angVel) {
            body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
        }
        objeto.userData.physicsBody = body;
        objeto.userData.collided = false;
        objeto.userData.tempoInicial = new Date();
        cena.add(objeto);
        if (mass > 0) {
            corposRigidos.push(objeto);
            body.setActivationState(4);
        }
        mundoFisico.addRigidBody(body);
        return body;
    }
    function criarCorAleatoria() {
        return Math.floor(Math.random() * (1 << 24));
    }
    function createMaterial(color) {
        color = color || criarCorAleatoria();
        return new THREE.MeshPhongMaterial({ color: color });
    }
    function inicEntradas() {
        imgBola = carregadorTextura.load('../materials/txtBasquete.jpeg', texture => texture);
        window.addEventListener('pointerdown', function (evento) {
            if (evento.button === 0) {
                controles && controles.isLocked && (controles.pointerSpeed = 0);
                if (Array.from(cena.children).includes(medGlob))
                    cena.remove(medGlob);
                tempIni = new Date();
                medGlob = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshPhongMaterial({ color: 0x801010, map: imgBola, opacity: 0.15, transparent: true, flatShading: true, depthTest: false, emissiveIntensity: 0, emissiveMap: imgBola }));
                medGlob.layers.enable(1);
                let dir = camera.getWorldDirection(new THREE.Vector3(0, 1.8, 0));
                medGlob.position.set(dir.x * 10, dir.y * 10, dir.z * 10);
                medGlob.rotation.y = Math.random() * Math.PI;
                medGlob.rotation.x = Math.random() * Math.PI;
                medGlob.rotation.z = Math.random() * Math.PI;
                cena.add(medGlob);
                carregando = true;
            }
        });
        window.addEventListener('touchmove' || 'touchcancel', (evento) => {
            evento.preventDefault();
            carregando && window.dispatchEvent(new Event('pointerup'));
        });
        window.addEventListener('pointerup', function (evento) {
            if (evento.button === 0) {
                passeBrilho.strength = 0.05;
                let _rot = new THREE.Euler(medGlob.rotation._x, medGlob.rotation._y, medGlob.rotation._z);
                controles && controles.isLocked && (controles.pointerSpeed = 0.75);
                tempFin = new Date();
                carregando = false;
                cena.remove(medGlob);
                if (controles && controles.isLocked || dispMovVal) {
                    let multEscala = (tempFin - tempIni) / 40;
                    lancadorRaios.setFromCamera(coordLancamento, camera);
                    const bolaMassa = 0.45;
                    const bolaRadius = 0.35;
                    !bolaMaterial.map && (bolaMaterial.map = imgBola) && (bolaMaterial.needsUpdate = true);
                    const bola = new THREE.Mesh(new THREE.SphereGeometry(bolaRadius, 16, 16), bolaMaterial);
                    bola.rotation.set(_rot._x, _rot._y, _rot._z);
                    bola.castShadow = true;
                    bola.receiveShadow = true;
                    const bolaShape = new Ammo.btSphereShape(bolaRadius);
                    bolaShape.setMargin(margem);
                    pos.copy(lancadorRaios.ray.direction);
                    pos.add(lancadorRaios.ray.origin);
                    quat.set(0, 0, 0, 1);
                    const bolaBody = criarCorpoRigido(bola, bolaShape, bolaMassa, pos, quat);
                    pos.copy(lancadorRaios.ray.direction);
                    pos.multiplyScalar(multEscala);
                    bolaBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
                }
            }
        });
    }
    function aoRedimensionarJanela() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        geradorImagem.setSize(window.innerWidth, window.innerHeight);
        compositorBrilho.renderer.setSize(window.innerWidth, window.innerHeight);
        compositorFinal.renderer.setSize(window.innerWidth, window.innerHeight);
        passeAntiCerrilhamento.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * window.devicePixelRatio);
        passeAntiCerrilhamento.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * window.devicePixelRatio);
    }
    function animar() {
        render();
        //estado.update();
        requestAnimationFrame(animar);
    }
    let materiais = {}, luzes = {};
    function render() {
        const deltaT = clock.getDelta();
        calcularFisica(deltaT);
        if (!carregando) {
            geradorImagem.render(cena, camera);
        } else {
            cena.traverse(objeto => {
                if (objeto.isMesh) {
                    if (!camadaBrilho.test(objeto.layers)) {
                        materiais[objeto.uuid] = objeto.material;
                        objeto.material = new THREE.MeshBasicMaterial({ color: 'black' });
                    }
                } else {
                    if (objeto.isLight) {
                        luzes[objeto.uuid] = objeto.intensity;
                        objeto.intensity = 0;
                    }
                }
            });
            compositorBrilho.render();
            cena.traverse(objeto => {
                if (objeto.isMesh) {
                    if (!camadaBrilho.test(objeto.layers)) {
                        objeto.material = materiais[objeto.uuid];
                    }
                } else {
                    if (objeto.isLight) {
                        objeto.intensity = luzes[objeto.uuid];
                    }
                }
            });
            compositorFinal.render();
        }

    }
    window.parent.addEventListener('atualizarPontuacao', async evento => {
        if (!evento.composed) {
            await contaPontos.splice(0, contaPontos.length);
            reporCesta();
        }
    });
    function reporCesta() {
        cestaEmCena.forEach(async (objeto, indice) => {
            await cena.remove(objeto);
            await mundoFisico.removeCollisionObject(cestaFisicaEmCena[indice]);
            if (indice + 1 === cestaEmCena.length) {
                await cena.remove(luzDestaqueEmCena[0]);
                cestaFisicaEmCena = [];
                luzDestaqueEmCena = [];
                cestaEmCena = [];
                carregarCesta();
            }
        });
    }
    const fontes = ['helvetiker', 'gentilis', 'optimer'];
    function calcularFisica(deltaT) {
        /**
        if (dispMovVal) {
            camera.rotation.x = (camera.rotation.x + xRotG) / 2;
            camera.rotation.z = (camera.rotation.z + zRotG) / 2;
            camera.rotation.y = (camera.rotation.y + yRotG) / 2;
        }
        **/
        mundoFisico.stepSimulation(deltaT, 10);
        for (let i = 0, il = corposRigidos.length; i < il; i++) {
            if (corposRigidos[i]) {
                const objThree = corposRigidos[i];
                const objFis = objThree.userData.physicsBody;
                const objTemp = objThree.userData.tempoInicial;
                const estadoMovimento = objFis.getMotionState();
                if (estadoMovimento) {
                    estadoMovimento.getWorldTransform(transformAux1);
                    const p = transformAux1.getOrigin();
                    const q = transformAux1.getRotation();
                    objThree.position.set(p.x(), p.y(), p.z());
                    objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    objThree.geometry.computeBoundingSphere();
                    if (objThree.position.distanceTo(posCesta) < objThree.geometry.parameters.radius / 2) {
                        if (contaPontos.every(ponto => ponto.bola !== i)) {
                            contaPontos.push({ bola: i });
                            window.parent.contaPontos = contaPontos;
                            window.parent.dispatchEvent(new Event("atualizarPontuacao", { composed: true }));
                            //let selecao = Math.floor(Math.random() * fontes.length);
                            carregadorFonte.load('/fontes/' + fontes[2] + '_bold.typeface.json', fonte => {
                                let geometriaTexto = new TextGeometry('+5s', {
                                    font: fonte,
                                    size: 0.25,
                                    depth: 0.05,
                                    curveSegments: 12,
                                    bevelEnabled: false
                                });
                                let materialTexto = new THREE.MeshStandardMaterial({ color: criarCorAleatoria(), transparent: true, emissive: criarCorAleatoria(), emissiveIntensity: Math.random() });
                                let objeto = new THREE.Mesh(geometriaTexto, materialTexto);
                                cena.add(objeto);
                                objeto.position.x = posCesta.x;
                                objeto.position.y = posCesta.y;
                                objeto.position.z = posCesta.z;
                                objeto.lookAt(0, posCesta.y, 0);
                                objeto.rotation.y * 1.1;
                                let animacao = setInterval(() => {
                                    objeto.scale.x += 0.05;
                                    objeto.scale.y += 0.05;
                                    objeto.scale.z += 0.05;
                                    objeto.material.opacity -= 0.01;
                                }, 16.6);
                                setTimeout(() => {
                                    cena.remove(objeto);
                                    clearInterval(animacao);
                                }, 1500);
                                reporCesta();
                            });
                        }
                    } else {
                        if (objThree.position.distanceTo(capsulaCamera.position) > 20 || new Date() - objTemp > 15000) {
                            corposRigidos.splice(i, 1, null);
                            let animacao = setInterval(() => {
                                if (objThree.scale.x > 0) {
                                    objThree.scale.x -= 0.01;
                                    objThree.scale.y -= 0.01;
                                    objThree.scale.z -= 0.01;
                                } else {
                                    removerDestrocos(objThree);
                                    clearInterval(animacao);
                                }
                            }, 16.6);
                            break;
                        }
                    }
                    objThree.userData.collided = false;
                }
            }
        }
        for (let i = 0, il = despachante.getNumManifolds(); i < il; i++) {
            const contactManifold = despachante.getManifoldByIndexInternal(i);
            const rb0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
            const rb1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);
            const objetoThree0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
            const objetoThree1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;
            if (!objetoThree0 && !objetoThree1) {
                continue;
            }
            const userData0 = objetoThree0 ? objetoThree0.userData : null;
            const userData1 = objetoThree1 ? objetoThree1.userData : null;
            const quebravel0 = userData0 ? userData0.breakable : false;
            const quabravel1 = userData1 ? userData1.breakable : false;
            const colidido0 = userData0 ? userData0.collided : false;
            const colidido1 = userData1 ? userData1.collided : false;
            if ((!quebravel0 && !quabravel1) || (colidido0 && colidido1)) {
                continue;
            }
            let contato = false;
            let impulsoMax = 0;
            for (let j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {
                const pontoContato = contactManifold.getContactPoint(j);
                if (pontoContato.getDistance() < 0) {
                    contato = true;
                    const impulso = pontoContato.getAppliedImpulse();
                    if (impulso > impulsoMax) {
                        impulsoMax = impulso;
                        const pos = pontoContato.get_m_positionWorldOnB();
                        const normal = pontoContato.get_m_normalWorldOnB();
                        pontoImpacto.set(pos.x(), pos.y(), pos.z());
                        normalImpacto.set(normal.x(), normal.y(), normal.z());
                    }
                    break;
                }
            }
            if (!contato) continue;
            const impulsoFraturante = 250;
            if (quebravel0 && !colidido0 && impulsoMax > impulsoFraturante) {
                const destrocos = quabravelConvexo.subdivideByImpact(objetoThree0, pontoImpacto, normalImpacto, 1, 2, 1.5);
                const numObjects = destrocos.length;
                for (let j = 0; j < numObjects; j++) {
                    const vel = rb0.getLinearVelocity();
                    const angVel = rb0.getAngularVelocity();
                    const fragmento = destrocos[j];
                    fragmento.userData.velocity.set(vel.x(), vel.y(), vel.z());
                    fragmento.userData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());
                    criarDestrocosDeObjetoQuebravel(fragmento);
                }
                objetosARemover[numObjectsToRemove++] = objetoThree0;
                userData0.collided = true;
            }
            if (quabravel1 && !colidido1 && impulsoMax > impulsoFraturante) {
                const destrocos = quabravelConvexo.subdivideByImpact(objetoThree1, pontoImpacto, normalImpacto, 1, 2, 1.5);
                const numObjects = destrocos.length;
                for (let j = 0; j < numObjects; j++) {
                    const vel = rb1.getLinearVelocity();
                    const angVel = rb1.getAngularVelocity();
                    const fragmento = destrocos[j];
                    fragmento.userData.velocity.set(vel.x(), vel.y(), vel.z());
                    fragmento.userData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());
                    criarDestrocosDeObjetoQuebravel(fragmento);
                }
                objetosARemover[numObjectsToRemove++] = objetoThree1;
                userData1.collided = true;
            }
        }
        for (let i = 0; i < numObjectsToRemove; i++) {
            removerDestrocos(objetosARemover[i]);
        }
        numObjectsToRemove = 0;
    }
</script>

<body
    style="background: transparent !important; width: max-content !important; height: max-content !important; overflow: hidden !important; margin: 0 !important; -webkit-touch-callout: none; -webkit-user-callout: none; -webkit-user-select: none; -webkit-user-drag: none; -webkit-user-modify: none; -webkit-highlight: none;">
    <div id="threeRenderer"
        style="width: max-content !important; height: max-content !important; overflow: hidden !important;">
    </div>
</body>

</html>
